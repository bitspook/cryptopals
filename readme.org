#+title: Cryptopals
#+author: Charanjit Singh
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="scss/main.scss"/>
#+HTML_HEAD: <script type="module" src="./index.tsx"></script>
#+OPTIONS: html-style:nil num:nil creator:comment

This page is me solving [[https://cryptopals.com/sets/1/challenges/6][cryptopals challenges]] with Rust, and taking
notes. UI widgets accompanying the rust snippets are running the wasm
compiled version of the snippet.

#+begin_quote
Please note that although I am publishing this publicly, I am learning
a bunch of things at the same time here. So don't take my word for
anything; be vigilant about mistakes and misstatements.
#+end_quote

* Set 1 
 
** Challenge 1: Convert Hex to Base64
:PROPERTIES:
:header-args: :tangle src/set1/challenge1.rs :comments link
:END:

First challenge is straightforward enough, we are given a HEX encoded
string, and we have to encode it to base64 instead. I decided to not
go down the rabbit hole here and use the libraries which handle
encoding/decoding to/from hex/base64.

#+begin_src rust :exports none
  use anyhow::{Result, Error};

  use wasm_bindgen::prelude::*;	
#+end_src

#+begin_src rust 
  pub fn hex_to_b64(input: &str) -> Result<String> {
      let hex_str = hex::decode(input).map_err(Error::from)?;
      let out = base64::encode(hex_str);

      Ok(out)
  }
#+end_src

I am using [[https://github.com/dtolnay/anyhow][anyhow]] library to return =anyhow::Result= here; because it
is convenient. I also use it in my (relatively) bigger rust
applications.

#+begin_src rust :exports none
  #[wasm_bindgen]
  pub fn hex_to_b64_web(input: &str) -> String {
      hex_to_b64(input).unwrap()
  }
#+end_src

You can play around with the result of above code.

#+begin_export html 
<play-function
  fn="cryptopals.hex_to_b64_web"
  display-name="hex_to_b64"
  error-message="Input is not a valid HEX encoded string"
></play-function>
#+end_export

Entering the test string given in the [[https://cryptopals.com/sets/1/challenges/1][challenge]] produce the expected
output.
 
But let's go a step further and write a test! One of the things I like
about rust is how easy it makes to write tests. We can drop the
following snippet in the same file and =cargo test= will run it. The
lack of friction makes for a great developer experience.

#+begin_src rust
  #[cfg(test)]
  mod tests {
      use super::*;

      #[test]
      fn s1e1_hex_to_b64() {
	  let input = "49276d206b696c6c696e6720796f757220627261696e206c696b65206120706f69736f6e6f7573206d757368726f6f6d";
	  let output = "SSdtIGtpbGxpbmcgeW91ciBicmFpbiBsaWtlIGEgcG9pc29ub3VzIG11c2hyb29t";

	  assert_eq!(hex_to_b64(input).unwrap(), output);
      }
  }
#+end_src

** Challenge 2: Fixed XOR
:PROPERTIES:
:header-args: :tangle src/set1/challenge2.rs :comments link
:END:

Next challenge is not particularly challenging either. We are given
two strings of equal length, and we have to perform XOR bitwise
operation on them. We can simply use rust's =^= operator, which does
exactly that.

But, this time let's tart with writing tests first.

#+begin_src rust :exports none
  use wasm_bindgen::prelude::*;
#+end_src

#+begin_src rust
  #[cfg(test)]
  mod tests {
      use super::*;

      #[test]
      fn test_xor() {
	  let b1 = hex::decode("1c0111001f010100061a024b53535009181c").unwrap();
	  let b2 = hex::decode("686974207468652062756c6c277320657965").unwrap();
	  let expected = "746865206b696420646f6e277420706c6179";

	  assert_eq!(xor(&b1, &b2), hex::decode(expected).unwrap());
      }

      #[test]
      fn test_hexor() {
	  assert_eq!(
	      hexor(
		  "1c0111001f010100061a024b53535009181c",
		  "686974207468652062756c6c277320657965"
	      ),
	      "746865206b696420646f6e277420706c6179"
	  )
      }
  }
#+end_src

We are given two hex encoded strings, which we'll first decode. In the
first challenge, it was recommended that we should work directly with
bytes when we can; instead of any encoded form of strings. So we'll
write our =xor= function to accept references to byte arrays (=u8= is
one byte), and return a new byte array with every byte of one buffer
XOR'd against that of second.

But I am not sure how to use =&[u8]= in Javascript, and I am not
willing to put time in this right now (I am side-questing a lot
already), so we'll also create a helper which can work directly with
strings. We'll call it =hexor= to put emphasis on the fact that its
input strings are hex encoded.

#+begin_src rust
  pub fn xor(b1: &[u8], b2: &[u8]) -> Vec<u8> {
      let mut result: Vec<u8> = vec![];

      for i in 0..b1.len() {
          result.push(b1[i] ^ b2[i]);
      }

      result
  }

  #[wasm_bindgen]
  pub fn hexor(s1: &str, s2: &str) -> String {
      let b1 = hex::decode(s1).unwrap();
      let b2 = hex::decode(s2).unwrap();

      hex::encode(xor(&b1, &b2))
  }
#+end_src

#+begin_export html
<play-function
  fn="cryptopals.hexor"
  display-name="hexor"
  error-message="Both arguments must be value hex encoded strings"
  args="string, string"
  ></play-function>
#+end_export

# Local Variables:
# org-html-htmlize-font-prefix: "hljs-"
# org-html-htmlize-output-type: css
# End:
